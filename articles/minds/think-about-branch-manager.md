# 关于版本管理的思考

现在多人开发基本都要用上 git 或 TortoiseHg 之类的代码管理工具，<br />
即便小公司也希望有网盘或 SVN 或私有云等留档和共享方案。

而这其中绝大概率会遇到版本管理这事，让版本的回退/对比/合并等操作成为可能。<br />
在面试期间了解队伍的代码管理规范，也能多少窥见一些团队特色的信息。

## 分支管理

分支管理的好处当然是隔离，只要我不拉取就不会被别人的代码影响。

撇开像网盘和 SVN 那种没有分支走到底，或者就独苗一个全提 master 的情况，<br />
分支管理习惯上大致可分为 **按人分配** 和 **按任务分配** 两种。 

### 个人分支

每个人都是独立的分支，只会与主分支相关。<br />

通常是先摸鸡主分支到本分支再开发再摸鸡主分支到本分支，再提测本分支到主分支。

往往将一整块任务分配给此人，由此人独立开发，别人想在开发期间帮忙都比较难。<br />
举个反例，某人开发效率较慢，导致整个版本都无法提测，<br />
或者某人手头上有多个问题在修复，偷个懒就一起提了，后面想回退就麻烦了。<br />

故而，本方案适用于那种 经常任务量不大 / 不常合伙开发 / 上线周期不固定 的队伍。

### 任务分支

严格按任务建立分支，每个需求节点和 BUG 修复都可建立新分支，十分独立。<br />

通常是依赖某版本新建分支后开发，开发完成后提测主分支。

此方案非常依赖任务管理流程，任务拆分/上线周期等往往都有节制。<br />
因此对需求/修复/版本有一定区分，也即 feature/hotfix/release。<br />
这也使得分支命名/注释/操作规范等要求更多也更严格。<br />
也因任务过细难以通晓和冲突概率更高，加入代码审查环节是相当必要的。

故而，本方案适用于 上线有周期 / 有项目管理 / 人手较多 的队伍。

## 测试分支

开发环境与正式环境分离，这是必要的架构设计，代码管理也不例外。<br />
一方面是为了正式环境的稳定，另一方面也是让纠错有更多缓和的空间。<br />

通常是 dev/test/master 或 uat/pre/prd 这样的命名。<br />

在不同测试环境拉取不同测试分支的代码进行打包部署，<br />
上个测试环境测试通过后合并到下个测试分支，再打包部署，<br />
对测试人员来说更易掌握主动权，只需控制这几个分支的合并即可。

当然，不使用分支区分而是在部署时进行区分也阔以，但有些就不太好自动化了。

如果面试时你发现该团队没有测试分支方案时，你可能就要面对测试人员常来找你的尴尬了。

## 版本与标签

在开发的语境中，每个 commit 便是版本，<br />
而在产品的与语境中，某些 release 才是版本，而对开发这叫标签。

在有测试分支架构的版本管理中，通常会有 uat-sync 或 stable 之类的模板分支，<br />
用于新建新任务分支时的基础版本，以此版本开始开发会比较稳定。

uat-sync 即可视为标签，给某个 release 版本打上 v1.0 标签，也是类似的效果。<br />
当然，标签亦可是独立分支的形态，也是一样的。

如果用 master 分支作为模板分支，或使用个人分支方案，会面临需要经常合并的情况。

## 代码审查

开发完成后会提交到主分支，比如个人分支方案提到 master，任务分支方案提到 uat。<br />
有的是直接推送，有的则需要走 create merge request 再同意合并再推送。

后者在同意前即可进行代码审查，主要是高手们对代码理解后进行调教的过程了，<br />
可能是 规范纠错/实现方案的意见/处理冲突/统筹项目进程 等方面的辅助。

不仅如此，有的团队，在 push 前也有审查，主要是 eslint 等方面的自动化检查。

应该只会在流程严格和人手较多的团队里才会出现吧。

## 合并策略

在提交主分支之前，有的团队会要求先合并主分支到本分支，处理完冲突再提交；<br />
而有的团队则是直接提交主分支，有冲突由代码审查人员处理，再推送。

其实两种都不错，在不容易知晓所有任务细节的团队，还是选用后者吧。

另外，发现个人分支方案的开发者在提交时更喜欢用 rebase 操作，<br />
因为其被分配的任务相对较大，为了方便回退会更频繁的 commit，造成分支查看界面又臭又长，<br />
如果合并完主分支到本分支，处理完冲突准备提交前，rebase 一下，那么 commit 就会合并一些。
